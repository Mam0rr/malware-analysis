#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")


void send_http_response(int client_fd, int status_code, const char* content_type, const char* body) {
    char response[1024];
    const char* status_line;

    switch (status_code) {
    case 200:
        status_line = "HTTP/1.1 200 OK\r\n";
        break;
    case 404:
        status_line = "HTTP/1.1 404 Not Found\r\n";
        break;
    case 500:
        status_line = "HTTP/1.1 500 Internal Server Error\r\n";
        break;
    default:
        status_line = "HTTP/1.1 500 Internal Server Error\r\n";
        break;
    }

    snprintf(response, sizeof(response),
        "%s"
        "Content-Type: %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        status_line, content_type, strlen(body), body);

    send(client_fd, response, strlen(response), 0);
}

int InitialiseSocket()
{

    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    {
        perror("WSAStartup failed");
        return EXIT_FAILURE;
    }

    SOCKET serverfd;
    struct sockaddr_in serverAddr;

    serverfd = socket(AF_INET, SOCK_STREAM, 0);

    if (serverfd < 0)
    {
        perror("Socket failed to initialise");
        closesocket(serverfd);
        return EXIT_FAILURE;
    }

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(8080);

    if (bind(serverfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0)
    {
        perror("Failed to bind");
        closesocket(serverfd);
        return EXIT_FAILURE;
    }

    if (listen(serverfd, 10) < 0)
    {
        perror("Socket failed to listen");
        closesocket(serverfd);
        return EXIT_FAILURE;
    }

    return serverfd;
}


DWORD WINAPI handle_client(LPVOID client_fd_ptr) {
    int client_fd = *(int*)client_fd_ptr;
    free(client_fd_ptr);

    char buffer[1024];
    while (TRUE) { 
        int recv_size = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
        if (recv_size <= 0) {
            printf("Client disconnected or error receiving data.\n");
            break; 
        }

        buffer[recv_size] = '\0'; // Null terminate the received data
        printf("Received request: %s\n", buffer);

        // Check if the request was recognized (for example, an HTTP GET request)
        if (strstr(buffer, "GET")) {
            char command[256];
            printf("Enter command to send to client: ");

            if (fgets(command, sizeof(command), stdin) != NULL) {
                // Remove newline character if present
                size_t len = strlen(command);
                if (len > 0 && command[len - 1] == '\n') {
                    command[len - 1] = '\0';
                }

                if (strcmp(command, "exit") == 0) {
                    printf("Closing connection to client.\n");
                    break; 
                }

                char response[512];
                snprintf(response, sizeof(response),
                    "HTTP/1.1 200 OK\r\n"
                    "Content-Type: text/plain\r\n"
                    "Connection: close\r\n"
                    "\r\n"
                    "Command to execute: %s\n", command);

                send(client_fd, response, strlen(response), 0);
            }
        }
        else {
            // If the request is not recognized, send a 404 response
            const char* not_found_response =
                "HTTP/1.1 404 Not Found\r\n"
                "Content-Type: text/plain\r\n"
                "Connection: close\r\n"
                "\r\n"
                "404 Not Found\n";

            send(client_fd, not_found_response, strlen(not_found_response), 0);
        }
    }

    closesocket(client_fd);
    return 0;
}
void HandleConnections(int serverfd)
{
    while (TRUE)
    {
        struct sockaddr_in clientAddr;
        int client_len = sizeof(clientAddr);

        int* client_fd = malloc(client_len);

        *client_fd = accept(serverfd, (struct sockaddr*)&clientAddr, &client_len);

        if (*client_fd < 0)
        {
            perror("Failed to accept client");
            free(client_fd);
            continue;
        }

        HANDLE thread_handle;
        DWORD thread_id;
        thread_handle = CreateThread(NULL, 0, handle_client, (LPVOID)client_fd, 0, &thread_id);

        if (thread_handle == NULL)
        {
            perror("Failed to create thread");
            closesocket(*client_fd);
            free(client_fd);
            continue;
        }

        CloseHandle(thread_handle);
    }
}

int main()
{
    int serverfd = InitialiseSocket();
    if (serverfd == EXIT_FAILURE)
    {
        return EXIT_FAILURE;
    }

    HandleConnections(serverfd);

    closesocket(serverfd);
    WSACleanup();
    return 0;
}
