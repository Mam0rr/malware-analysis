#include <Windows.h>
#include <stdio.h>

#define TRAMPOLINE_SIZE 13

typedef unsigned long long uint64_t;
typedef unsigned int uint32_t;
typedef unsigned char uint8_t;

// Variables to hold original function bytes and memory protection
BYTE  originalBytes[TRAMPOLINE_SIZE];
DWORD oldProtection;

// Function to initialise the hook
BOOL InitialiseHook(PVOID functionToHook) {
    // Save the original bytes for restoration
    memcpy(originalBytes, functionToHook, TRAMPOLINE_SIZE);

    // Change memory protection to allow modification
    if (!VirtualProtect(functionToHook, TRAMPOLINE_SIZE, PAGE_EXECUTE_READWRITE, &oldProtection)) {
        printf("[ERROR] Unable to change memory protection. Error code: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

// Function to install the hook
BOOL InstallHook(PVOID functionToHook, PVOID functionToRun) {
    if (!functionToHook || !functionToRun) {
        printf("[ERROR] Invalid parameters passed to InstallHook.\n");
        return FALSE;
    }

    // Trampoline shellcode
    uint8_t trampolineInstructions[] = {
        0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, functionToRun
        0xFF, 0xE0                                                  // jmp rax
    };

    // Patch trampoline with the target function address
    uint64_t addressToPatch = (uint64_t)functionToRun;
    memcpy(&trampolineInstructions[2], &addressToPatch, sizeof(addressToPatch));

    // Write the trampoline shellcode to the target function
    memcpy(functionToHook, trampolineInstructions, sizeof(trampolineInstructions));

    return TRUE;
}

// Function to remove the hook
BOOL RemoveHook(PVOID functionToHook) {
    DWORD temporaryProtection;

    // Restore original bytes
    memcpy(functionToHook, originalBytes, TRAMPOLINE_SIZE);

    // Restore original memory protection
    if (!VirtualProtect(functionToHook, TRAMPOLINE_SIZE, oldProtection, &temporaryProtection)) {
        printf("[ERROR] Failed to restore memory protection. Error code: %d\n", GetLastError());
        return FALSE;
    }

    // Clear the backup buffer
    memset(originalBytes, 0, TRAMPOLINE_SIZE);

    return TRUE;
}

// Replacement function for MessageBoxA
INT WINAPI CustomMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
    printf("[INFO] Hook triggered. Intercepted parameters:\n");
    printf("\t- Text   : %s\n", lpText);
    printf("\t- Caption: %s\n", lpCaption);

    return MessageBoxW(hWnd, L"The function has been successfully hooked!", L"Hooked Message Box", uType);
}

// Entry point
int main() {
    PVOID originalMessageBox = &MessageBoxA;

    // Initialise the hook
    if (!InitialiseHook(originalMessageBox)) {
        printf("[ERROR] Hook initialisation failed.\n");
        return EXIT_FAILURE;
    }

    // Install the hook
    printf("[INFO] Installing the hook...\n");
    if (!InstallHook(originalMessageBox, &CustomMessageBoxA)) {
        printf("[ERROR] Hook installation failed.\n");
        return EXIT_FAILURE;
    }
    printf("[SUCCESS] Hook successfully installed.\n");

    // Test hooked function
    MessageBoxA(NULL, "This is the original message box.", "Original Message Box", MB_OK | MB_ICONINFORMATION);

    // Remove the hook
    printf("[INFO] Removing the hook...\n");
    if (!RemoveHook(originalMessageBox)) {
        printf("[ERROR] Failed to remove the hook.\n");
        return EXIT_FAILURE;
    }
    printf("[SUCCESS] Hook successfully removed.\n");

    // Test original function again
    MessageBoxA(NULL, "This is the original message box.", "Original Message Box", MB_OK | MB_ICONINFORMATION);

    return EXIT_SUCCESS;
}
