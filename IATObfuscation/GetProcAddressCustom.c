#include <windows.h>
#include <iostream> 
#include <cstdio>

FARPROC GetProcAddressReplacement(HMODULE moduleHandle, LPCSTR functionName) {
    if (moduleHandle == NULL || functionName == NULL) {
        return NULL; 
    }

    
    PBYTE baseAddress = (PBYTE)moduleHandle;


    /*
    //0x40 bytes (sizeof)
    struct _IMAGE_DOS_HEADER
    {
        USHORT e_magic;             //0x0   
        USHORT e_cblp;              //0x2
        ...
        LONG e_lfanew;              //0x3c
    }; */

    // Check if the file starts with the correct MZ signature (0x5A4D).
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;
    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL; 
    }

    // Check if the file contains a valid NT header by verifying the NT signature (0x00004550).
    // The e_lfanew field from the DOS header points to the offset of the NT headers.
    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)(baseAddress + dosHeader->e_lfanew);
    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return NULL;
    }



    /*0xf0 bytes (sizeof)
        struct _IMAGE_OPTIONAL_HEADER64
    {
        USHORT Magic;                                             //0x0
        UCHAR MajorLinkerVersion;                                 //0x2
        UCHAR MinorLinkerVersion;                                 //0x3
        ...
        struct _IMAGE_DATA_DIRECTORY DataDirectory[16];          //0x70
    }; */



    // Get the optonal header and make sure it has a DataDirectory.
    const IMAGE_OPTIONAL_HEADER* optionalHeader = &ntHeaders->OptionalHeader;
    if (optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0) {
        return NULL; 
    }

    /*0x8 bytes (sizeof)
    struct _IMAGE_DATA_DIRECTORY
    {
        ULONG VirtualAddress;          //0x0
        ULONG Size;                    //0x4
    };*/

    // Calculate the address of the export directory using the virtual address from the optional header. (ModuleHeader + exportDirectoryRVA)
    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)(
        baseAddress + optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    if (exportDirectory == NULL || exportDirectory->NumberOfNames == 0) {
        return NULL;
    }

    // Get pointers to the function names, addresses, and ordinals from the export directory.
    PDWORD FuncNamesArray = (PDWORD)(baseAddress + exportDirectory->AddressOfNames);
    PDWORD FuncaddressesArray = (PDWORD)(baseAddress + exportDirectory->AddressOfFunctions);
    PWORD ordinalsArray = (PWORD)(baseAddress + exportDirectory->AddressOfNameOrdinals);

    // Loop through all function names in the export directory (FuncNamesArray) to find a match and retrieve the corresponding function address (FuncaddressesArray).
    for (DWORD index = 0; index < exportDirectory->NumberOfNames; index++) {
        LPCSTR exportedFunctionName = (LPCSTR)(baseAddress + FuncNamesArray[index]);

        if (strcmp(functionName, exportedFunctionName) == 0) {
            FARPROC exportedFunctionAddress = (FARPROC)(baseAddress + FuncaddressesArray[ordinalsArray[index]]);
            return exportedFunctionAddress;
        }
    }
    return NULL;
}

int main()
{
    HMODULE moduleHandle = GetModuleHandleA("kernel32.dll"); 
    if (moduleHandle) {
        FARPROC functionAddress = GetProcAddressReplacement(moduleHandle, "CompareStringA");
        if (functionAddress) {
            std::cout << "Function found at address: " << functionAddress << "\n";
        } else {
            std::cout << "Function not found.\n";
        }
    } else {
        std::cout << "Failed to load module.\n";
    }

    return 0;
}
